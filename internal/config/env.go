package config

import (
	"fmt"
	"os"
	"strings"

	"github.com/templatr/templatr-setup/internal/manifest"
)

// EnvFileTarget returns the target file path for an env var.
// If the env var has no File field set, it defaults to ".env".
func EnvFileTarget(env manifest.EnvVar) string {
	if env.File != "" {
		return env.File
	}
	return ".env"
}

// GroupEnvByFile groups env vars by their target file.
// Returns a map of file path -> env vars, and an ordered list of unique file paths.
func GroupEnvByFile(envDefs []manifest.EnvVar) (map[string][]manifest.EnvVar, []string) {
	grouped := make(map[string][]manifest.EnvVar)
	var order []string
	seen := make(map[string]bool)

	for _, env := range envDefs {
		target := EnvFileTarget(env)
		if !seen[target] {
			order = append(order, target)
			seen[target] = true
		}
		grouped[target] = append(grouped[target], env)
	}

	return grouped, order
}

// WriteEnvFiles writes env vars to their respective target files.
// It groups vars by their File field and writes each group to the corresponding file.
func WriteEnvFiles(envDefs []manifest.EnvVar, values map[string]string) error {
	grouped, order := GroupEnvByFile(envDefs)

	for _, file := range order {
		defs := grouped[file]
		if err := WriteEnvFile(file, defs, values); err != nil {
			return fmt.Errorf("writing %s: %w", file, err)
		}
	}

	return nil
}

// WriteEnvFile writes a .env file with the given values.
// It preserves field order from the manifest and adds comments.
func WriteEnvFile(path string, envDefs []manifest.EnvVar, values map[string]string) error {
	var b strings.Builder

	b.WriteString("# Generated by templatr-setup\n")
	b.WriteString("# See .templatr.toml for field descriptions\n\n")

	for i, env := range envDefs {
		// Comment with description
		if env.Description != "" {
			b.WriteString(fmt.Sprintf("# %s\n", env.Description))
		}
		if env.DocsURL != "" {
			b.WriteString(fmt.Sprintf("# Docs: %s\n", env.DocsURL))
		}

		value := ""
		if v, ok := values[env.Key]; ok {
			value = v
		}

		// Quote values that contain spaces or special characters
		if needsQuoting(value) {
			b.WriteString(fmt.Sprintf("%s=\"%s\"\n", env.Key, escapeEnvValue(value)))
		} else {
			b.WriteString(fmt.Sprintf("%s=%s\n", env.Key, value))
		}

		if i < len(envDefs)-1 {
			b.WriteString("\n")
		}
	}

	return os.WriteFile(path, []byte(b.String()), 0o644)
}

// ReadEnvFile reads existing .env values from a file.
func ReadEnvFile(path string) (map[string]string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return map[string]string{}, nil
		}
		return nil, err
	}

	values := make(map[string]string)
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		idx := strings.IndexByte(line, '=')
		if idx < 0 {
			continue
		}

		key := strings.TrimSpace(line[:idx])
		value := strings.TrimSpace(line[idx+1:])

		// Remove surrounding quotes
		if len(value) >= 2 {
			if (value[0] == '"' && value[len(value)-1] == '"') ||
				(value[0] == '\'' && value[len(value)-1] == '\'') {
				value = value[1 : len(value)-1]
			}
		}

		values[key] = value
	}

	return values, nil
}

func needsQuoting(s string) bool {
	return strings.ContainsAny(s, " \t\"'\\#$")
}

func escapeEnvValue(s string) string {
	s = strings.ReplaceAll(s, `\`, `\\`)
	s = strings.ReplaceAll(s, `"`, `\"`)
	return s
}
